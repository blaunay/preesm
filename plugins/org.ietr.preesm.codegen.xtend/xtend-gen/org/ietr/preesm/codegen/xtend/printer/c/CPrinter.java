/**
 * Copyright or © or Copr. IETR/INSA: Maxime Pelcat, Jean-François Nezan,
 * Karol Desnos, Julien Heulot
 * 
 * [mpelcat,jnezan,kdesnos,jheulot]@insa-rennes.fr
 * 
 * This software is a computer program whose purpose is to prototype
 * parallel applications.
 * 
 * This software is governed by the CeCILL-C license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL-C
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * 
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * 
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * 
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
package org.ietr.preesm.codegen.xtend.printer.c;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IntegerRange;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.ietr.preesm.codegen.xtend.model.codegen.Block;
import org.ietr.preesm.codegen.xtend.model.codegen.Buffer;
import org.ietr.preesm.codegen.xtend.model.codegen.CallBlock;
import org.ietr.preesm.codegen.xtend.model.codegen.CodeElt;
import org.ietr.preesm.codegen.xtend.model.codegen.Communication;
import org.ietr.preesm.codegen.xtend.model.codegen.CommunicationNode;
import org.ietr.preesm.codegen.xtend.model.codegen.Constant;
import org.ietr.preesm.codegen.xtend.model.codegen.ConstantString;
import org.ietr.preesm.codegen.xtend.model.codegen.CoreBlock;
import org.ietr.preesm.codegen.xtend.model.codegen.Delimiter;
import org.ietr.preesm.codegen.xtend.model.codegen.Direction;
import org.ietr.preesm.codegen.xtend.model.codegen.FifoCall;
import org.ietr.preesm.codegen.xtend.model.codegen.FifoOperation;
import org.ietr.preesm.codegen.xtend.model.codegen.FunctionCall;
import org.ietr.preesm.codegen.xtend.model.codegen.LoopBlock;
import org.ietr.preesm.codegen.xtend.model.codegen.Semaphore;
import org.ietr.preesm.codegen.xtend.model.codegen.SharedMemoryCommunication;
import org.ietr.preesm.codegen.xtend.model.codegen.SpecialCall;
import org.ietr.preesm.codegen.xtend.model.codegen.SubBuffer;
import org.ietr.preesm.codegen.xtend.model.codegen.Variable;
import org.ietr.preesm.codegen.xtend.printer.DefaultPrinter;
import org.ietr.preesm.codegen.xtend.task.CodegenException;

/**
 * This printer is currently used to print C code only for X86 processor with
 * shared memory communication.
 * 
 * @author kdesnos
 */
@SuppressWarnings("all")
public class CPrinter extends DefaultPrinter {
  /**
   * Temporary global var to ignore the automatic suppression of memcpy
   * whose target and destination are identical.
   */
  protected boolean IGNORE_USELESS_MEMCPY = true;
  
  public CharSequence printCoreBlockHeader(final CoreBlock block) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/** ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* @file ");
    String _name = block.getName();
    _builder.append(_name, " ");
    _builder.append(".c");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("* @generated by ");
    Class<? extends CPrinter> _class = this.getClass();
    String _simpleName = _class.getSimpleName();
    _builder.append(_simpleName, " ");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("* @date ");
    Date _date = new Date();
    _builder.append(_date, " ");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include \"../include/x86.h\"");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printDefinitionsHeader(final List<Variable> list) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _isEmpty = list.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("// Core Global Definitions");
        _builder.newLine();
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  public CharSequence printBufferDefinition(final Buffer buffer) {
    StringConcatenation _builder = new StringConcatenation();
    String _type = buffer.getType();
    _builder.append(_type, "");
    _builder.append(" ");
    String _name = buffer.getName();
    _builder.append(_name, "");
    _builder.append("[");
    int _size = buffer.getSize();
    _builder.append(_size, "");
    _builder.append("]; // ");
    String _comment = buffer.getComment();
    _builder.append(_comment, "");
    _builder.append(" size:= ");
    int _size_1 = buffer.getSize();
    _builder.append(_size_1, "");
    _builder.append("*");
    String _type_1 = buffer.getType();
    _builder.append(_type_1, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence printSubBufferDefinition(final SubBuffer buffer) {
    StringConcatenation _builder = new StringConcatenation();
    String _type = buffer.getType();
    _builder.append(_type, "");
    _builder.append(" *const ");
    String _name = buffer.getName();
    _builder.append(_name, "");
    _builder.append(" = (");
    String _type_1 = buffer.getType();
    _builder.append(_type_1, "");
    _builder.append("*) (");
    int offset = 0;
    Buffer _xblockexpression = null;
    {
      int _offset = buffer.getOffset();
      offset = _offset;
      Buffer b = buffer.getContainer();
      boolean _while = (b instanceof SubBuffer);
      while (_while) {
        {
          int _offset_1 = ((SubBuffer) b).getOffset();
          int _plus = (offset + _offset_1);
          offset = _plus;
          Buffer _container = ((SubBuffer) b).getContainer();
          b = _container;
        }
        _while = (b instanceof SubBuffer);
      }
      _xblockexpression = (b);
    }
    String _name_1 = _xblockexpression.getName();
    _builder.append(_name_1, "");
    _builder.append("+");
    _builder.append(offset, "");
    _builder.append(");  // ");
    String _comment = buffer.getComment();
    _builder.append(_comment, "");
    _builder.append(" size:= ");
    int _size = buffer.getSize();
    _builder.append(_size, "");
    _builder.append("*");
    String _type_2 = buffer.getType();
    _builder.append(_type_2, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence printDefinitionsFooter(final List<Variable> list) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _isEmpty = list.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  public CharSequence printDeclarationsHeader(final List<Variable> list) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// Core Global Declaration");
    _builder.newLine();
    _builder.append("extern pthread_barrier_t iter_barrier;");
    _builder.newLine();
    _builder.append("extern int stopThreads;");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printBufferDeclaration(final Buffer buffer) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("extern ");
    CharSequence _printBufferDefinition = this.printBufferDefinition(buffer);
    _builder.append(_printBufferDefinition, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence printSubBufferDeclaration(final SubBuffer buffer) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("extern ");
    String _type = buffer.getType();
    _builder.append(_type, "");
    _builder.append(" *const ");
    String _name = buffer.getName();
    _builder.append(_name, "");
    _builder.append(";  // ");
    String _comment = buffer.getComment();
    _builder.append(_comment, "");
    _builder.append(" size:= ");
    int _size = buffer.getSize();
    _builder.append(_size, "");
    _builder.append("*");
    String _type_1 = buffer.getType();
    _builder.append(_type_1, "");
    _builder.append(" defined in ");
    Block _creator = buffer.getCreator();
    String _name_1 = _creator.getName();
    _builder.append(_name_1, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence printDeclarationsFooter(final List<Variable> list) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _isEmpty = list.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  public CharSequence printCoreInitBlockHeader(final CallBlock callBlock) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("void *computationThread_");
    EObject _eContainer = callBlock.eContainer();
    String _name = ((CoreBlock) _eContainer).getName();
    _builder.append(_name, "");
    _builder.append("(void *arg){");
    _builder.newLineIfNotEmpty();
    {
      EList<CodeElt> _codeElts = callBlock.getCodeElts();
      boolean _isEmpty = _codeElts.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("\t");
        _builder.append("// Initialisation(s)");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  public CharSequence printCoreLoopBlockHeader(final LoopBlock block2) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("\t", "");
    _builder.append("// Begin the execution loop ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("while(1){");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("pthread_barrier_wait(&iter_barrier);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if(stopThreads){");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("pthread_exit(NULL);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printCoreLoopBlockFooter(final LoopBlock block2) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printFifoCall(final FifoCall fifoCall) {
    String _xblockexpression = null;
    {
      FifoOperation _operation = fifoCall.getOperation();
      String _string = _operation.toString();
      String _lowerCase = _string.toLowerCase();
      String _firstUpper = StringExtensions.toFirstUpper(_lowerCase);
      String _plus = ("fifo" + _firstUpper);
      String result = (_plus + "(");
      FifoOperation _operation_1 = fifoCall.getOperation();
      boolean _notEquals = (!Objects.equal(_operation_1, FifoOperation.INIT));
      if (_notEquals) {
        EList<Variable> _parameters = fifoCall.getParameters();
        Variable _head = IterableExtensions.<Variable>head(_parameters);
        Buffer buffer = ((Buffer) _head);
        StringConcatenation _builder = new StringConcatenation();
        CharSequence _doSwitch = this.doSwitch(buffer);
        _builder.append(_doSwitch, "");
        _builder.append(", ");
        String _plus_1 = (result + _builder);
        result = _plus_1;
      }
      StringConcatenation _builder_1 = new StringConcatenation();
      Buffer _headBuffer = fifoCall.getHeadBuffer();
      String _name = _headBuffer.getName();
      _builder_1.append(_name, "");
      _builder_1.append(", ");
      Buffer _headBuffer_1 = fifoCall.getHeadBuffer();
      int _size = _headBuffer_1.getSize();
      _builder_1.append(_size, "");
      _builder_1.append("*sizeof(");
      Buffer _headBuffer_2 = fifoCall.getHeadBuffer();
      String _type = _headBuffer_2.getType();
      _builder_1.append(_type, "");
      _builder_1.append("), ");
      String _plus_2 = (result + _builder_1);
      result = _plus_2;
      StringConcatenation _builder_2 = new StringConcatenation();
      {
        Buffer _bodyBuffer = fifoCall.getBodyBuffer();
        boolean _notEquals_1 = (!Objects.equal(_bodyBuffer, null));
        if (_notEquals_1) {
          Buffer _bodyBuffer_1 = fifoCall.getBodyBuffer();
          String _name_1 = _bodyBuffer_1.getName();
          _builder_2.append(_name_1, "");
          _builder_2.append(", ");
          Buffer _bodyBuffer_2 = fifoCall.getBodyBuffer();
          int _size_1 = _bodyBuffer_2.getSize();
          _builder_2.append(_size_1, "");
          _builder_2.append("*sizeof(");
          Buffer _bodyBuffer_3 = fifoCall.getBodyBuffer();
          String _type_1 = _bodyBuffer_3.getType();
          _builder_2.append(_type_1, "");
          _builder_2.append(")");
        } else {
          _builder_2.append("NULL, 0");
        }
      }
      _builder_2.append(");");
      _builder_2.newLineIfNotEmpty();
      String _plus_3 = (result + _builder_2);
      String _result = result = _plus_3;
      _xblockexpression = (_result);
    }
    return _xblockexpression;
  }
  
  public CharSequence printFork(final SpecialCall call) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// Fork ");
    String _name = call.getName();
    _builder.append(_name, "");
    EList<Buffer> _inputBuffers = call.getInputBuffers();
    Buffer input = IterableExtensions.<Buffer>head(_inputBuffers);
    int index = 0;
    _builder.newLineIfNotEmpty();
    _builder.append("{");
    _builder.newLine();
    {
      EList<Buffer> _outputBuffers = call.getOutputBuffers();
      for(final Buffer output : _outputBuffers) {
        _builder.append("\t");
        int _size = output.getSize();
        String _type = output.getType();
        CharSequence _printMemcpy = this.printMemcpy(output, 0, input, index, _size, _type);
        _builder.append(_printMemcpy, "	");
        String _xblockexpression = null;
        {
          int _size_1 = output.getSize();
          int _plus = (_size_1 + index);
          index = _plus;
          _xblockexpression = ("");
        }
        _builder.append(_xblockexpression, "	");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printBroadcast(final SpecialCall call) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// Broadcast ");
    String _name = call.getName();
    _builder.append(_name, "");
    EList<Buffer> _inputBuffers = call.getInputBuffers();
    Buffer input = IterableExtensions.<Buffer>head(_inputBuffers);
    int index = 0;
    _builder.newLineIfNotEmpty();
    _builder.append("{");
    _builder.newLine();
    {
      EList<Buffer> _outputBuffers = call.getOutputBuffers();
      for(final Buffer output : _outputBuffers) {
        int outputIdx = 0;
        _builder.newLineIfNotEmpty();
        {
          int _size = output.getSize();
          int _size_1 = input.getSize();
          int _divide = (_size / _size_1);
          int _plus = (_divide + 1);
          IntegerRange _upTo = new IntegerRange(0, _plus);
          for(final Integer nbIter : _upTo) {
            {
              int _size_2 = output.getSize();
              boolean _lessThan = (outputIdx < _size_2);
              if (_lessThan) {
                _builder.append("\t");
                int _size_3 = output.getSize();
                int _minus = (_size_3 - outputIdx);
                int _size_4 = input.getSize();
                int _minus_1 = (_size_4 - index);
                final int value = Math.min(_minus, _minus_1);
                String _type = output.getType();
                CharSequence _printMemcpy = this.printMemcpy(output, outputIdx, input, index, value, _type);
                _builder.append(_printMemcpy, "	");
                String _xblockexpression = null;
                {
                  int _plus_1 = (index + value);
                  int _size_5 = input.getSize();
                  int _modulo = (_plus_1 % _size_5);
                  index = _modulo;
                  int _plus_2 = (outputIdx + value);
                  outputIdx = _plus_2;
                  _xblockexpression = ("");
                }
                _builder.append(_xblockexpression, "	");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printRoundBuffer(final SpecialCall call) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// RoundBuffer ");
    String _name = call.getName();
    _builder.append(_name, "");
    EList<Buffer> _outputBuffers = call.getOutputBuffers();
    Buffer output = IterableExtensions.<Buffer>head(_outputBuffers);
    int index = 0;
    int inputIdx = 0;
    _builder.newLineIfNotEmpty();
    ArrayList<Buffer> _xblockexpression = null;
    {
      EList<Buffer> _inputBuffers = call.getInputBuffers();
      final Function2<Integer,Buffer,Integer> _function = new Function2<Integer,Buffer,Integer>() {
          public Integer apply(final Integer res, final Buffer buf) {
            int _size = buf.getSize();
            int _plus = ((res).intValue() + _size);
            return Integer.valueOf(_plus);
          }
        };
      Integer totalSize = IterableExtensions.<Buffer, Integer>fold(_inputBuffers, Integer.valueOf(0), _function);
      ArrayList<Buffer> _arrayList = new ArrayList<Buffer>();
      ArrayList<Buffer> lastInputs = _arrayList;
      inputIdx = (totalSize).intValue();
      EList<Buffer> _inputBuffers_1 = call.getInputBuffers();
      int _size = _inputBuffers_1.size();
      int i = (_size - 1);
      int _minus = ((totalSize).intValue() - inputIdx);
      int _size_1 = output.getSize();
      boolean _lessThan = (_minus < _size_1);
      boolean _while = _lessThan;
      while (_while) {
        {
          EList<Buffer> _inputBuffers_2 = call.getInputBuffers();
          Buffer _get = _inputBuffers_2.get(i);
          int _size_2 = _get.getSize();
          int _minus_1 = (inputIdx - _size_2);
          inputIdx = _minus_1;
          EList<Buffer> _inputBuffers_3 = call.getInputBuffers();
          Buffer _get_1 = _inputBuffers_3.get(i);
          lastInputs.add(0, _get_1);
          int _minus_2 = (i - 1);
          i = _minus_2;
        }
        int _minus_1 = ((totalSize).intValue() - inputIdx);
        int _size_2 = output.getSize();
        boolean _lessThan_1 = (_minus_1 < _size_2);
        _while = _lessThan_1;
      }
      int _size_2 = output.getSize();
      int _modulo = (inputIdx % _size_2);
      inputIdx = _modulo;
      _xblockexpression = (lastInputs);
    }
    ArrayList<Buffer> copiedInBuffers = _xblockexpression;
    _builder.newLineIfNotEmpty();
    _builder.append("{");
    _builder.newLine();
    {
      for(final Buffer input : copiedInBuffers) {
        {
          int _size = input.getSize();
          int _size_1 = output.getSize();
          int _divide = (_size / _size_1);
          int _plus = (_divide + 1);
          IntegerRange _upTo = new IntegerRange(0, _plus);
          for(final Integer nbIter : _upTo) {
            {
              int _size_2 = input.getSize();
              boolean _lessThan = (inputIdx < _size_2);
              if (_lessThan) {
                _builder.append("\t");
                int _size_3 = input.getSize();
                int _minus = (_size_3 - inputIdx);
                int _size_4 = output.getSize();
                int _minus_1 = (_size_4 - index);
                final int value = Math.min(_minus, _minus_1);
                String _type = input.getType();
                CharSequence _printMemcpy = this.printMemcpy(output, index, input, inputIdx, value, _type);
                _builder.append(_printMemcpy, "	");
                String _xblockexpression_1 = null;
                {
                  int _plus_1 = (index + value);
                  int _size_5 = output.getSize();
                  int _modulo = (_plus_1 % _size_5);
                  index = _modulo;
                  int _plus_2 = (inputIdx + value);
                  inputIdx = _plus_2;
                  _xblockexpression_1 = ("");
                }
                _builder.append(_xblockexpression_1, "	");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printJoin(final SpecialCall call) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// Join ");
    String _name = call.getName();
    _builder.append(_name, "");
    EList<Buffer> _outputBuffers = call.getOutputBuffers();
    Buffer output = IterableExtensions.<Buffer>head(_outputBuffers);
    int index = 0;
    _builder.newLineIfNotEmpty();
    _builder.append("{");
    _builder.newLine();
    {
      EList<Buffer> _inputBuffers = call.getInputBuffers();
      for(final Buffer input : _inputBuffers) {
        _builder.append("\t");
        int _size = input.getSize();
        String _type = input.getType();
        CharSequence _printMemcpy = this.printMemcpy(output, index, input, 0, _size, _type);
        _builder.append(_printMemcpy, "	");
        String _xblockexpression = null;
        {
          int _size_1 = input.getSize();
          int _plus = (_size_1 + index);
          index = _plus;
          _xblockexpression = ("");
        }
        _builder.append(_xblockexpression, "	");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * Print a memcpy call in the generated code. Unless
   * {@link #IGNORE_USELESS_MEMCPY} is set to <code>true</code>, this method
   * checks if the destination and the source of the memcpy are superimposed.
   * In such case, the memcpy is useless and nothing is printed.
   * 
   * @param output
   *            the destination {@link Buffer}
   * @param outOffset
   *            the offset in the destination {@link Buffer}
   * @param input
   *            the source {@link Buffer}
   * @param inOffset
   *            the offset in the source {@link Buffer}
   * @param size
   *            the amount of memory to copy
   * @param type
   *            the type of objects copied
   * @return a {@link CharSequence} containing the memcpy call (if any)
   */
  public CharSequence printMemcpy(final Buffer output, final int outOffset, final Buffer input, final int inOffset, final int size, final String type) {
    CharSequence _xblockexpression = null;
    {
      int totalOffsetOut = outOffset;
      Buffer bOutput = output;
      boolean _while = (bOutput instanceof SubBuffer);
      while (_while) {
        {
          int _offset = ((SubBuffer) bOutput).getOffset();
          int _plus = (totalOffsetOut + _offset);
          totalOffsetOut = _plus;
          Buffer _container = ((SubBuffer) bOutput).getContainer();
          bOutput = _container;
        }
        _while = (bOutput instanceof SubBuffer);
      }
      int totalOffsetIn = inOffset;
      Buffer bInput = input;
      boolean _while_1 = (bInput instanceof SubBuffer);
      while (_while_1) {
        {
          int _offset = ((SubBuffer) bInput).getOffset();
          int _plus = (totalOffsetIn + _offset);
          totalOffsetIn = _plus;
          Buffer _container = ((SubBuffer) bInput).getContainer();
          bInput = _container;
        }
        _while_1 = (bInput instanceof SubBuffer);
      }
      CharSequence _xifexpression = null;
      boolean _and = false;
      boolean _and_1 = false;
      if (!this.IGNORE_USELESS_MEMCPY) {
        _and_1 = false;
      } else {
        boolean _equals = Objects.equal(bInput, bOutput);
        _and_1 = (this.IGNORE_USELESS_MEMCPY && _equals);
      }
      if (!_and_1) {
        _and = false;
      } else {
        boolean _equals_1 = (totalOffsetIn == totalOffsetOut);
        _and = (_and_1 && _equals_1);
      }
      if (_and) {
        StringConcatenation _builder = new StringConcatenation();
        _xifexpression = _builder;
      } else {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("memcpy(");
        CharSequence _doSwitch = this.doSwitch(output);
        _builder_1.append(_doSwitch, "");
        _builder_1.append("+");
        _builder_1.append(outOffset, "");
        _builder_1.append(", ");
        CharSequence _doSwitch_1 = this.doSwitch(input);
        _builder_1.append(_doSwitch_1, "");
        _builder_1.append("+");
        _builder_1.append(inOffset, "");
        _builder_1.append(", ");
        _builder_1.append(size, "");
        _builder_1.append("*sizeof(");
        _builder_1.append(type, "");
        _builder_1.append("));");
        _xifexpression = _builder_1;
      }
      _xblockexpression = (_xifexpression);
    }
    return _xblockexpression;
  }
  
  public CharSequence caseCommunication(final Communication communication) {
    try {
      CharSequence _xifexpression = null;
      EList<CommunicationNode> _nodes = communication.getNodes();
      final Function1<CommunicationNode,Boolean> _function = new Function1<CommunicationNode,Boolean>() {
          public Boolean apply(final CommunicationNode it) {
            String _type = it.getType();
            boolean _equals = Objects.equal(_type, "SHARED_MEM");
            return Boolean.valueOf(_equals);
          }
        };
      boolean _forall = IterableExtensions.<CommunicationNode>forall(_nodes, _function);
      if (_forall) {
        CharSequence _caseCommunication = super.caseCommunication(communication);
        _xifexpression = _caseCommunication;
      } else {
        String _name = communication.getName();
        String _plus = ("Communication " + _name);
        String _plus_1 = (_plus + 
          " has at least one unsupported communication node");
        String _plus_2 = (_plus_1 + 
          " for the ");
        Class<? extends CPrinter> _class = this.getClass();
        String _name_1 = _class.getName();
        String _plus_3 = (_plus_2 + _name_1);
        String _plus_4 = (_plus_3 + " printer");
        CodegenException _codegenException = new CodegenException(_plus_4);
        throw _codegenException;
      }
      return _xifexpression;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public CharSequence printSharedMemoryCommunication(final SharedMemoryCommunication communication) {
    StringConcatenation _builder = new StringConcatenation();
    Direction _direction = communication.getDirection();
    String _string = _direction.toString();
    String _lowerCase = _string.toLowerCase();
    _builder.append(_lowerCase, "");
    Delimiter _delimiter = communication.getDelimiter();
    String _string_1 = _delimiter.toString();
    String _lowerCase_1 = _string_1.toLowerCase();
    String _firstUpper = StringExtensions.toFirstUpper(_lowerCase_1);
    _builder.append(_firstUpper, "");
    _builder.append("(");
    {
      Semaphore _semaphore = communication.getSemaphore();
      boolean _notEquals = (!Objects.equal(_semaphore, null));
      if (_notEquals) {
        _builder.append("&");
        Semaphore _semaphore_1 = communication.getSemaphore();
        String _name = _semaphore_1.getName();
        _builder.append(_name, "");
        _builder.append("/*ID*/");
      }
    }
    _builder.append("); // ");
    Communication _sendStart = communication.getSendStart();
    CoreBlock _coreContainer = _sendStart.getCoreContainer();
    String _name_1 = _coreContainer.getName();
    _builder.append(_name_1, "");
    _builder.append(" > ");
    Communication _receiveStart = communication.getReceiveStart();
    CoreBlock _coreContainer_1 = _receiveStart.getCoreContainer();
    String _name_2 = _coreContainer_1.getName();
    _builder.append(_name_2, "");
    _builder.append(": ");
    Buffer _data = communication.getData();
    CharSequence _doSwitch = this.doSwitch(_data);
    _builder.append(_doSwitch, "");
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence printFunctionCall(final FunctionCall functionCall) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = functionCall.getName();
    _builder.append(_name, "");
    _builder.append("(");
    {
      EList<Variable> _parameters = functionCall.getParameters();
      boolean _hasElements = false;
      for(final Variable param : _parameters) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "");
        }
        CharSequence _doSwitch = this.doSwitch(param);
        _builder.append(_doSwitch, "");
      }
    }
    _builder.append("); // ");
    String _actorName = functionCall.getActorName();
    _builder.append(_actorName, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence printConstant(final Constant constant) {
    StringConcatenation _builder = new StringConcatenation();
    long _value = constant.getValue();
    _builder.append(_value, "");
    {
      String _name = constant.getName();
      boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_name);
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        _builder.append("/*");
        String _name_1 = constant.getName();
        _builder.append(_name_1, "");
        _builder.append("*/");
      }
    }
    return _builder;
  }
  
  public CharSequence printConstantString(final ConstantString constant) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\"");
    String _value = constant.getValue();
    _builder.append(_value, "");
    _builder.append("\"");
    return _builder;
  }
  
  public CharSequence printBuffer(final Buffer buffer) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = buffer.getName();
    _builder.append(_name, "");
    return _builder;
  }
  
  public CharSequence printSubBuffer(final SubBuffer buffer) {
    CharSequence _printBuffer = this.printBuffer(buffer);
    return _printBuffer;
  }
  
  public CharSequence printSemaphore(final Semaphore semaphore) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("&");
    String _name = semaphore.getName();
    _builder.append(_name, "");
    return _builder;
  }
  
  public CharSequence printSemaphoreDefinition(final Semaphore semaphore) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("sem_t ");
    String _name = semaphore.getName();
    _builder.append(_name, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence printSemaphoreDeclaration(final Semaphore semaphore) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("extern sem_t ");
    String _name = semaphore.getName();
    _builder.append(_name, "");
    _builder.append("; ");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
}
